---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by z1178.
--- DateTime: 29/10/2022 17:26
---

setmetatable(_G, {
    __newindex = function(_, n)
        error("attempt to write to undeclared variable" .. n, 2)
    end,
    __index = function(_, n)
        error("attempt to read undeclared variable" .. n, 2)
    end
})

--- 这段代码执行后，所有试图对不存在全局变量的访问都将引发一个错误∶
---但是，我们应该如何声明一个新的变量呢?方法之一是使用函数rawset，它可以绕过元方法∶
--function declare(name, initval)
--    rawset(_G, name, initval or faLse)
--end
---_G中除了自定义的全局变量，还包括许多Lua预定义的函数，比如print、math、io等。
for n in pairs(_G)
do
    print(n)    --打印出_G表中的所有变量
end

--a = 123
--local b = 456
--print(_G.a)     --123，等价于  print(_G["a"])
--print(_G.b)     --nil，局部变量并没有保存在_G中

--local z = 10
--x = y + z
--- lua把所有代码段都当作匿名函数来处理，并且把代码段中未显式声明的变量xx转换为_ENV.xx，因此上述代码会被编译成如下形式
--local z = 10
--_ENV.x = _ENV.y + z

--_Env是什么呢？它是lua中的一个预定义上值(upvalue)。因为我们说过，lua中根本就不存在全局变量，
--为了能够让用户产生Lua中有全局变量的错觉，Lua将_Env表被设计成一个upvalue，所有的代码段都当作是匿名函数，
--所以上面的代码实际上被编译成如下的样子

--local _ENV = the global environment(全局环境)
--return function (...)
--    local z = 10
--    _ENV.x = _ENV.y + z
--end
--Lua通过使用预定义上值 _ENV 表来保存全局变量，所有对全局变量的访问都是通过_Env引用得到，如果我们将_Env设为nil，则后续的代码都不能直接访问全局变量，包括print在内

--让我们总结一下Lua语言中处理全局变量的方式：
--编译器在编译所有代码段前，在外层创建局部变量 _ENV；
--编译器将所有自由名称var变换为 _ENV.var；
--函数load（或函数loadfile）使用全局环境初始化代码段的第一个upvalue，即Lua语言内部维护的一个普通的表。

--前面提到_Env是一个upvalue类型的table， 什么是upvalue呢？可以理解为在当前语句作用域（scope）之上的值，一个带有upvalue的函数，我们称之为闭包，通过一个例子直观感受一下。
local upval = 1
local upval2 = 2
function out()
    local locvar = 3
    print(upval)
    local function inner()
        print(upval + upval2 + locvar)
    end
    inner()
end
--上面例子中，out函数外部定义了upval和upval2两个变量，并且内部引用了upval变量，因此upval是函数out的一个upvalue，它内部的函数inner引用了变量upval2，因此upval2也是out的上值，而inner函数有三个上值，分别是upval、upval2和locvar。


---https://zhuanlan.zhihu.com/p/474429680